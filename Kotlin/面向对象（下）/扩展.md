# 扩展

> Kotlin 支持扩展方法和扩展属性



## 扩展方法

只要定义一个函数，在函数名前加 ***类名*** 和 **.** 就行

~~~kotlin
class Test{
    
}
//为Test类扩展方法
fun Test.test(){
    println("扩展的方法")
}
~~~

* **扩展方法也会被子类继承**
* **扩展方法中也可以使用this**



## 扩展的实现机制

​		Java是一门静态语言，实际上，Kotlin的扩展并没有真正地修改所扩展的类。Kotlin扩展的本质是定义了一个函数，当程序用对象调用扩展方法时，Kotlin在编译时会执行静态解析——就是根据调用对象、方法名找到扩展函数，转换为函数调用。

​		如下代码：

~~~kotlin
fun main(){
    val t = Test()
    t.test()
}
~~~

Kotlin在编译时这行代码按如下步骤执行：

1. 检查 **t** 的类型，发现其类型是 **Test**

2. 检查 **Test** 类本身是否定义了 **test()** 方法，如果该类本身包含该方法，则 Kotlin 无需进行处理，直接编译即可

3. 如果 **Test** 类本身不包含 **test()** 方法，则 Kotlin 会查找程序是否为 **Test** 扩展了 **test()** 方法——也就是查找系统中是否包含了名为 **Test.test()** 的函数定义，如果找到该函数，则 Kotlin 编译器会执行静态解析，它会将上面代码替换成执行 **Test.test()** 函数

4. 如果 **Test** 不包含 **test()** 方法,也找不到名为 **Test.test()** 的函数定义，编译器将会报错

   

* 由上述可知，**调用扩展方法是由其所在表达式的编译时类型决定的，而不是由它所在表达式的运行时类型决定的（没有多态）**

~~~kotlin
class Base{
    
}
class Sub:Base(){
    
}
fun Base.foo(){
    println("Base的扩展函数")
}
fun Sub.foo(){
    println("Sub的扩展函数")
}

fun main(){
	val b:Base = Sub()
    b.foo()		// 输出"Base的扩展函数"，此处没有多态
}
~~~

> 成员方法执行动态解析，扩展方法执行静态解析

